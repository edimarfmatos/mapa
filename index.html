<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mapa do Depósito — Visão Aérea (Leaflet) — Versão Avançada</title>
  <!-- Leaflet + Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <style>
    /* --- Layout básico --- */
    html,body,#map { height:100%; margin:0; padding:0; }
    #map { position:fixed; inset:0; }
    .topright-panel {
      position: absolute; top: 10px; right: 10px; z-index: 1200;
      background: rgba(255,255,255,0.95); padding: 8px; border-radius:8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12); font-family: sans-serif; font-size:13px;
    }
    .btn { display:inline-block; margin:4px; padding:6px 8px; border-radius:6px; cursor:pointer; user-select:none; border:1px solid #ddd; }
    .btn.active { background:#eef; }
    .status { position:absolute; left:10px; bottom:10px; z-index:1200; background:rgba(255,255,255,0.95); padding:6px 8px; border-radius:6px; font-family:sans-serif; }
    .small { font-size:12px; color:#444 }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Painel de controles (zoom, seguir, desenho, voz, CTE) -->
  <div class="topright-panel" id="controls">
    <div>
      <span class="btn" id="zoom10">Visão ~10m</span>
      <span class="btn" id="zoom20">Visão ~20m</span>
      <span class="btn" id="follow">Seguir: OFF</span>
    </div>
    <div style="margin-top:6px">
      <span class="btn" id="startDraw">Iniciar Desenho</span>
      <span class="btn" id="stopDraw">Parar Desenho</span>
      <span class="btn" id="createCTE">Criar CTE</span>
      <span class="btn" id="deleteCTE">Deletar CTE</span>
    </div>
    <div style="margin-top:6px">
      <span class="btn" id="voiceToggle">Voz: OFF</span>
      <span class="btn" id="ttsTest">Ouvir Exemplo</span>
    </div>
    <div style="margin-top:6px; font-size:12px; color:#333">Centro inicial: localização atual (se permitida)</div>
  </div>

  <div class="status" id="status">Status: aguardando GPS...</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script>
    /* ------------------------------------------------------------------
       CONFIGURAÇÃO (edite conforme necessário)
       - APPS_SCRIPT_URL: quem receberá os POST/GET para salvar/carregar.
       - SYNC_INTERVAL: intervalo para sincronizar desenhos/CTEs do servidor
       ------------------------------------------------------------------ */
    const APPS_SCRIPT_URL = 'REPLACE_WITH_YOUR_APPS_SCRIPT_WEBAPP_URL';
    const SYNC_INTERVAL = 5000; // ms

    /* ------------------------------------------------------------------
       VARIÁVEIS GLOBAIS (estado da aplicação)
       ------------------------------------------------------------------ */
    const map = L.map('map', { zoomControl:true }).setView([0,0], 18);
    let userMarker = null;
    let follow = false;
    let isDrawingMode = false;            // modo de desenho ativado (manual/voz)
    let currentTrack = null;              // polyline temporária do trajeto em desenho
    let currentTrackCoords = [];         // lista de [lat,lng] atuais durante desenho
    let drawingStartPoint = null;        // ponto inicial [lat,lng] para fechamento automático
    const DRAW_CLOSE_THRESHOLD = 6;      // metros — distância para considerar "retorno" ao início

    // Camadas persistentes
    const drawingsLayer = L.geoJSON(null, { onEachFeature: attachFeaturePopup }).addTo(map);
    const cteLayer = L.featureGroup().addTo(map); // salvar marcadores de CTE aqui

    // Controls do Leaflet Draw (mantemos para edição manual também)
    const drawnItems = new L.FeatureGroup().addTo(map);
    const drawControl = new L.Control.Draw({ edit: { featureGroup: drawnItems, remove:true }, draw: { circle:false, circlemarker:false } });
    map.addControl(drawControl);

    /* ------------------------------------------------------------------
       Função utilitária: formatação e TTS
       ------------------------------------------------------------------ */
    function speak(text) {
      // Síntese de voz nativa (sem gerar MP3)
      if ('speechSynthesis' in window) {
        const u = new SpeechSynthesisUtterance(text);
        // opcional: ajustar voz/language/pitch
        u.lang = 'pt-BR';
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      } else {
        console.log('TTS não suportado neste navegador.');
      }
    }

    /* ------------------------------------------------------------------
       Inicialização do mapa e camadas base
       ------------------------------------------------------------------ */
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 22, attribution: '© OpenStreetMap' }).addTo(map);

    // Marcador do usuário (circleMarker para performance)
    userMarker = L.circleMarker([0,0], { radius:8 }).addTo(map).bindPopup('Você');

    const statusEl = document.getElementById('status');

    // Carrega desenhos e CTEs do servidor/localStorage
    async function loadAllFromServer() {
      if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('REPLACE_WITH')) {
        // fallback localStorage (útil para desenvolvimento sem Apps Script)
        const storedDrawings = JSON.parse(localStorage.getItem('drawings') || '[]');
        const storedCTEs = JSON.parse(localStorage.getItem('ctes') || '[]');
        drawingsLayer.clearLayers(); storedDrawings.forEach(s => drawingsLayer.addData(s.geojson));
        cteLayer.clearLayers(); storedCTEs.forEach(s => addCTEToMap(s));
        return;
      }

      try {
        const resp = await fetch(APPS_SCRIPT_URL + '?action=getAll');
        const data = await resp.json();
        drawingsLayer.clearLayers(); (data.drawings||[]).forEach(d => drawingsLayer.addData(d.geojson));
        cteLayer.clearLayers(); (data.ctes||[]).forEach(c => addCTEToMap(c));
      } catch (err) {
        console.error('Erro ao carregar do servidor', err);
      }
    }

    loadAllFromServer();
    setInterval(loadAllFromServer, SYNC_INTERVAL);

    /* ------------------------------------------------------------------
       Funções para salvar/deletar desenhos e CTEs (com fallback local)
       ------------------------------------------------------------------ */
    async function saveDrawingToServer(geojson) {
      if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('REPLACE_WITH')) {
        const stored = JSON.parse(localStorage.getItem('drawings') || '[]');
        stored.push({ id: Date.now().toString(), geojson });
        localStorage.setItem('drawings', JSON.stringify(stored));
        return;
      }
      try {
        await fetch(APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ action:'save_drawing', geojson }) });
      } catch (err) { console.error('Erro save drawing', err); }
    }

    async function deleteDrawingFromServer(geojson) {
      if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('REPLACE_WITH')) {
        const stored = JSON.parse(localStorage.getItem('drawings') || '[]');
        const serialized = JSON.stringify(geojson.geometry);
        const filtered = stored.filter(s => JSON.stringify(s.geojson.geometry) !== serialized);
        localStorage.setItem('drawings', JSON.stringify(filtered));
        return;
      }
      try {
        await fetch(APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ action:'delete_drawing', geojson }) });
      } catch (err) { console.error('Erro delete drawing', err); }
    }

    async function saveCTEToServer(cteObj) {
      if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('REPLACE_WITH')) {
        const stored = JSON.parse(localStorage.getItem('ctes') || '[]');
        stored.push(cteObj);
        localStorage.setItem('ctes', JSON.stringify(stored));
        return;
      }
      try {
        await fetch(APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ action:'save_cte', cte:cteObj }) });
      } catch (err) { console.error('Erro save cte', err); }
    }

    async function deleteCTEFromServer(cteNumber) {
      if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('REPLACE_WITH')) {
        const stored = JSON.parse(localStorage.getItem('ctes') || '[]');
        const filtered = stored.filter(s => s.cte !== cteNumber);
        localStorage.setItem('ctes', JSON.stringify(filtered));
        return;
      }
      try {
        await fetch(APPS_SCRIPT_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ action:'delete_cte', cte: cteNumber }) });
      } catch (err) { console.error('Erro delete cte', err); }
    }

    /* ------------------------------------------------------------------
       Helpers: popups, agregar CTE ao mapa
       ------------------------------------------------------------------ */
    function attachFeaturePopup(feature, layer) {
      // exibir propriedades relevantes
      if (feature && feature.properties) {
        let popup = '';
        if (feature.properties.cte) popup += '<b>CTE:</b> ' + feature.properties.cte + '<br>';
        if (feature.properties.loc) popup += '<b>Loc:</b> ' + feature.properties.loc + '<br>';
        if (popup) layer.bindPopup(popup);
      }
    }

    function addCTEToMap(cteObj) {
      // cteObj esperado: { cte: '123', loc: '001A', lat: x, lng: y, id: optional }
      const marker = L.marker([cteObj.lat, cteObj.lng]);
      marker.cteData = cteObj; // link para busca/deleção
      marker.bindPopup(`<b>CTE:</b> ${cteObj.cte}<br><b>Loc:</b> ${cteObj.loc}`);
      cteLayer.addLayer(marker);
    }

    /* ------------------------------------------------------------------
       Eventos do Leaflet Draw (permitir edição manual além do modo de track)
       ------------------------------------------------------------------ */
    map.on(L.Draw.Event.CREATED, e => {
      const layer = e.layer;
      // Perguntar dados do CTE se for um ponto, ou salvar como desenho
      if (layer instanceof L.Marker) {
        const cte = prompt('Digite o número do CTE (opcional):') || '';
        const loc = prompt('Digite o número da locação (opcional):') || '';
        const latlng = layer.getLatLng();
        const cteObj = { cte, loc, lat: latlng.lat, lng: latlng.lng, id: Date.now().toString() };
        addCTEToMap(cteObj);
        saveCTEToServer(cteObj);
      } else {
        const geo = layer.toGeoJSON();
        drawnItems.addLayer(layer);
        drawingsLayer.addData(geo);
        saveDrawingToServer(geo);
      }
    });

    map.on('draw:edited', e => { e.layers.eachLayer(layer => saveDrawingToServer(layer.toGeoJSON(), true)); });
    map.on('draw:deleted', e => { e.layers.eachLayer(layer => deleteDrawingFromServer(layer.toGeoJSON())); });

    /* ------------------------------------------------------------------
       GPS: pegar localização e atualizar marcador do usuário
       ------------------------------------------------------------------ */
    if ('geolocation' in navigator) {
      navigator.geolocation.getCurrentPosition(pos => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 18);
        userMarker.setLatLng([latitude, longitude]);
        statusEl.textContent = 'GPS inicializado — você está aqui!';
      }, err => { statusEl.textContent = 'Não foi possível obter a localização inicial.'; });

      navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        userMarker.setLatLng([latitude, longitude]);
        userMarker.bindPopup(`Você<br>Lat: ${latitude.toFixed(6)}<br>Lng: ${longitude.toFixed(6)}`);
        statusEl.textContent = `GPS ativo — precisão: ${accuracy ? accuracy.toFixed(1)+'m':'n/d'}`;
        if (follow) map.panTo([latitude, longitude]);
        // se estivermos no modo desenho por track, adiciona o ponto ao trajeto
        if (isDrawingMode) onTrackPositionUpdate([latitude, longitude]);
      }, err => { statusEl.textContent = 'Status: GPS indisponível ou não permitido.'; }, { enableHighAccuracy:true, maximumAge:1000, timeout:10000 });
    } else {
      statusEl.textContent = 'Geolocalização não suportada pelo navegador.';
    }

    /* ------------------------------------------------------------------
       MODO DESENHO POR TRACK (linha sendo construída enquanto o usuário anda)
       - startDrawingMode: configura e começa a armazenar pontos
       - stopDrawingMode: finaliza, salva como desenho (fechado se retornou)
       ------------------------------------------------------------------ */
    function startDrawingMode() {
      if (isDrawingMode) return;
      isDrawingMode = true;
      currentTrackCoords = [];
      if (currentTrack) { map.removeLayer(currentTrack); currentTrack = null; }
      drawingStartPoint = null;
      document.getElementById('startDraw').classList.add('active');
      speak('Modo desenho ativado. Comece a andar.');
    }

    async function stopDrawingMode() {
      if (!isDrawingMode) return;
      isDrawingMode = false;
      document.getElementById('startDraw').classList.remove('active');
      document.getElementById('stopDraw').classList.add('active');
      // criar GeoJSON da linha
      if (currentTrackCoords.length >= 2) {
        // se retornou ao ponto inicial (dentro do threshold), fechamos como polígono
        let geo;
        const first = currentTrackCoords[0];
        const last = currentTrackCoords[currentTrackCoords.length-1];
        const distToStart = getDistanceMeters(first, last);
        if (distToStart <= DRAW_CLOSE_THRESHOLD) {
          // cria polígono
          const polygonCoords = currentTrackCoords.map(c => [c[1], c[0]]); // GeoJSON espera [lng,lat]
          // fechar explicitamente
          polygonCoords.push([first[1], first[0]]);
          geo = { type:'Feature', geometry:{ type:'Polygon', coordinates:[ polygonCoords ] }, properties: { createdBy:'track' } };
          speak('Trajeto fechado automaticamente como polígono.');
        } else {
          // linha simples
          const lineCoords = currentTrackCoords.map(c => [c[1], c[0]]);
          geo = { type:'Feature', geometry:{ type:'LineString', coordinates: lineCoords }, properties: { createdBy:'track' } };
          speak('Trajeto salvo como linha.');
        }
        drawingsLayer.addData(geo);
        await saveDrawingToServer(geo);
      } else {
        speak('Trajeto muito curto. Nada foi salvo.');
      }

      // limpar estado temporário
      if (currentTrack) { map.removeLayer(currentTrack); currentTrack = null; }
      currentTrackCoords = [];
      drawingStartPoint = null;
      setTimeout(()=>document.getElementById('stopDraw').classList.remove('active'), 800);
    }

    function onTrackPositionUpdate(latlng) {
      // latlng = [lat, lng]
      if (!isDrawingMode) return;
      const [lat, lng] = latlng;
      // adicionar ao array
      currentTrackCoords.push([lat, lng]);
      // definir ponto inicial se ainda não houver
      if (!drawingStartPoint) drawingStartPoint = [lat, lng];
      // desenhar/atualizar polyline temporária
      if (!currentTrack) {
        currentTrack = L.polyline(currentTrackCoords, { weight:4, opacity:0.8 }).addTo(map);
      } else {
        currentTrack.setLatLngs(currentTrackCoords);
      }
      // verificar fechamento automático (se voltou perto do início)
      if (currentTrackCoords.length > 10) {
        const distToStart = getDistanceMeters(drawingStartPoint, [lat, lng]);
        if (distToStart <= DRAW_CLOSE_THRESHOLD) {
          // auto-stop — fechar desenho
          stopDrawingMode();
        }
      }
    }

    /* ------------------------------------------------------------------
       UTIL: distância entre 2 coordenadas (Haversine) -> metros
       ------------------------------------------------------------------ */
    function getDistanceMeters(a, b) {
      const toRad = v => v * Math.PI / 180;
      const lat1 = a[0], lon1 = a[1], lat2 = b[0], lon2 = b[1];
      const R = 6371000;
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const A = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2);
      const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
      return R * C;
    }

    /* ------------------------------------------------------------------
       COMANDOS DE VOZ: reconhecimento e parsing simples
       - Palavras chaves (pt-BR):
         * iniciar desenho / começar desenho  -> startDrawingMode()
         * parar desenho / finalizar desenho    -> stopDrawingMode()
         * criar cte / criar aqui cte           -> createCTEAtCurrentLocation()
         * deletar cte / deletar c te           -> prompt e deleteCTEByNumber()
       - O reconhecimento precisa de permissão do usuário.
       ------------------------------------------------------------------ */
    let recognition = null;
    let voiceActive = false;

    function initSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.log('SpeechRecognition não suportado');
        return;
      }
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SR();
      recognition.lang = 'pt-BR';
      recognition.interimResults = false;
      recognition.continuous = true;

      recognition.onresult = e => {
        const last = e.results[e.results.length -1];
        const text = last[0].transcript.trim().toLowerCase();
        console.log('Voz capturada:', text);
        handleVoiceCommand(text);
      };

      recognition.onstart = () => { console.log('Reconhecimento de voz iniciado'); };
      recognition.onend = () => { console.log('Reconhecimento de voz finalizado'); if (voiceActive) recognition.start(); };
      recognition.onerror = err => { console.error('Speech error', err); };
    }

    function toggleVoice() {
      voiceActive = !voiceActive;
      const el = document.getElementById('voiceToggle');
      el.textContent = 'Voz: ' + (voiceActive ? 'ON' : 'OFF');
      el.classList.toggle('active', voiceActive);
      if (!recognition) initSpeechRecognition();
      if (voiceActive) {
        try { recognition.start(); speak('Comandos de voz ativados.'); } catch (e) { console.error(e); }
      } else {
        try { recognition.stop(); speak('Comandos de voz desativados.'); } catch (e) { console.error(e); }
      }
    }

    async function handleVoiceCommand(text) {
      // simples correspondência de palavras-chave
      if (text.includes('iniciar desenho') || text.includes('começar desenho') || text.includes('abrir desenho')) {
        startDrawingMode(); return;
      }
      if (text.includes('parar desenho') || text.includes('finalizar desenho') || text.includes('encerrar desenho')) {
        await stopDrawingMode(); return;
      }
      if (text.includes('criar cte') || text.includes('cria cte') || text.includes('criar aqui cte') || text.includes('criar aqui')) {
        await createCTEAtCurrentLocation(true); return;
      }
      if (text.includes('deletar cte') || text.includes('excluir cte') || text.includes('deleta cte')) {
        await deleteCTEByVoice(); return;
      }

      // outras frases: buscar CTE
      if (text.startsWith('onde está') || text.startsWith('onde esta') || text.startsWith('procura cte')) {
        // procurar número no texto
        const maybeNumber = text.replace(/[^À-ſa-z0-9 ]+/g,'').split(' ').pop();
        await queryCTEByNumber(maybeNumber);
        return;
      }

      // fallback
      console.log('Comando de voz não reconhecido como ação. Texto:', text);
    }

    /* ------------------------------------------------------------------
       Funções de criação e deleção de CTE (botão + voz)
       ------------------------------------------------------------------ */
    async function createCTEAtCurrentLocation(useVoiceForInput=false) {
      // pega posição atual do usuário
      if (!userMarker) { speak('Localização do usuário desconhecida.'); return; }
      const latlng = userMarker.getLatLng();
      let cte = '';
      let loc = '';
      if (useVoiceForInput && voiceActive) {
        // pedir via TTS e ouvir (simples flow: falar e depois esperar input via prompt fallback)
        speak('Diga o número do C T E agora.');
        // O ideal seria usar reconhecimento contínuo com parsing contextual; por simplicidade, usamos prompt após a fala
        cte = prompt('Número do CTE (voz ativa — se preferir, digite):') || '';
      } else {
        cte = prompt('Número do CTE (opcional):') || '';
      }
      loc = prompt('Código de localização (por exemplo 001A) (opcional):') || '';

      const cteObj = { id: Date.now().toString(), cte, loc, lat: latlng.lat, lng: latlng.lng };
      addCTEToMap(cteObj);
      await saveCTEToServer(cteObj);
      speak('CTE criado. Registro salvo.');
    }

    async function deleteCTEByVoice() {
      // pedir número via prompt (ou podemos tentar ouvir via voz)
      const cteNumber = prompt('Número do CTE a deletar: (digite)') || '';
      if (!cteNumber) { speak('Operação cancelada.'); return; }
      // localizar no layer e remover
      let found = false;
      cteLayer.eachLayer(m => {
        if (m.cteData && m.cteData.cte === cteNumber) {
          cteLayer.removeLayer(m);
          found = true;
        }
      });
      if (found) {
        await deleteCTEFromServer(cteNumber);
        speak('CTE deletado.');
      } else {
        speak('CTE não encontrado.');
      }
    }

    async function deleteCTEByNumber(cteNumber) {
      // utilitário de chamada direta
      if (!cteNumber) return deleteCTEByVoice();
      cteLayer.eachLayer(m => { if (m.cteData && m.cteData.cte === cteNumber) cteLayer.removeLayer(m); });
      await deleteCTEFromServer(cteNumber);
      speak('CTE removido.');
    }

    async function queryCTEByNumber(cteNumber) {
      if (!cteNumber) { speak('Número do CTE não especificado.'); return; }
      // procurar localmente primeiro
      const matches = [];
      cteLayer.eachLayer(m => { if (m.cteData && m.cteData.cte === cteNumber) matches.push(m.cteData); });
      if (matches.length > 0) {
        const first = matches[0];
        map.setView([first.lat, first.lng], 19);
        speak(`CTE ${cteNumber} localizado na posição ${first.loc || 'sem código'}`);
      } else {
        // se não encontrado localmente, tentar buscar no servidor (se configurado)
        if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('REPLACE_WITH')) { speak('CTE não encontrado.'); return; }
        try {
          const resp = await fetch(APPS_SCRIPT_URL + `?action=find_cte&cte=${encodeURIComponent(cteNumber)}`);
          const data = await resp.json();
          if (data && data.lat) {
            map.setView([data.lat, data.lng], 19);
            speak(`CTE ${cteNumber} localizado no servidor na posição ${data.loc||'sem código'}`);
          } else speak('CTE não encontrado no servidor.');
        } catch (err) { console.error(err); speak('Erro ao buscar no servidor.'); }
      }
    }

    /* ------------------------------------------------------------------
       UI: ligar/desligar follow, zoom, botões
       ------------------------------------------------------------------ */
    document.getElementById('zoom10').onclick = ()=> map.setZoom(19);
    document.getElementById('zoom20').onclick = ()=> map.setZoom(17);
    const followBtn = document.getElementById('follow');
    followBtn.onclick = ()=> { follow = !follow; followBtn.textContent = 'Seguir: ' + (follow ? 'ON' : 'OFF'); followBtn.classList.toggle('active', follow); };

    document.getElementById('startDraw').onclick = startDrawingMode;
    document.getElementById('stopDraw').onclick = stopDrawingMode;
    document.getElementById('createCTE').onclick = ()=> createCTEAtCurrentLocation(false);
    document.getElementById('deleteCTE').onclick = deleteCTEByVoice;

    document.getElementById('voiceToggle').onclick = toggleVoice;
    document.getElementById('ttsTest').onclick = ()=> speak('Teste de leitura. Sistema pronto.');

    /* ------------------------------------------------------------------
       Inicializar reconhecimento de voz (não inicia automaticamente)
       ------------------------------------------------------------------ */
    initSpeechRecognition();

    /* ------------------------------------------------------------------
       Atalhos: salvar desenhos editados manualmente (quando o usuário usa o drawControl)
       - Exporta ao servidor sempre que desenhados via drawControl
       ------------------------------------------------------------------ */

    /* ------------------------------------------------------------------
       Comentários finais:
       - Este arquivo reúne: acompanhamento do usuário por GPS, modo de desenho
         por track (iniciado por botão ou por voz), criação/deleção de pontos
         CTE, TTS nativo e integração básica com Google Apps Script (via POST/GET).
       - Para integração completa com sua planilha Google, crie um Web App (Apps Script)
         que responda às actions: getAll, save_drawing, delete_drawing, save_cte, delete_cte, find_cte.
       - Se quiser, eu posso também gerar o modelo do Apps Script (lado servidor) que
         recebe essas ações e grava/consulta a planilha "Pal - Eco TBL" e as abas
         "MapadoDepósito"/"Mapa" conforme seu layout.
       ------------------------------------------------------------------ */
  </script>
</body>
</html>
